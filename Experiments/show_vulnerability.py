"""
This script demonstrates that the X_v point obtained by the MATLAB scripts
leads indeed to an incorrect result if the edge of the l-infinite robustness
- which the verifiers consider safe - is computed with a low precision implementation.

"""

import copy
import math
import sys

import numpy as np
from pynever import nodes
from pynever import utilities
from pynever.strategies.conversion import representation
from pynever.strategies.conversion.converters.onnx import ONNXConverter


def mulprec(a: np.ndarray, b: np.ndarray, d: int) -> np.ndarray:
    """Procedure to execute the matrix multiplication with custom precision"""
    a = a.T  # Need same dimension for multiplication

    # step 1: element-wise multiplication
    c = copy.deepcopy(b)
    for i in range(a.shape[0]):
        for j in range(a.shape[1]):
            c[i, j] = math.floor(float(a[i, j] * b[i, j]) * 10 ** d) / 10 ** d

    # step 2: sum
    res = np.zeros((1, b.shape[1]))
    for i in range(b.shape[1]):
        for j in range(a.shape[0]):
            res[0, i] = math.floor(float(res[0, i] + c[j, i]) * 10 ** d) / 10 ** d

    return res


sample = int(sys.argv[1])
model = int(sys.argv[2])
precision = int(sys.argv[3])

with open(f'Vulnerability/xv_{sample}_{model}_{precision}.csv', 'r') as xv_f:
    lines = xv_f.readlines()
    x_v = np.array([l.strip('\n').split(',') for l in lines], dtype=float)
    x_a = copy.deepcopy(x_v)

match model:
    case 0:
        onnx = representation.load_network_path(f'Networks/mnist_{sample}_bin_lin_{precision}.onnx')
    case 1:
        onnx = representation.load_network_path(f'Networks/mnist_{sample}_multi_lin_{precision}.onnx')
    case _:
        # TODO
        raise NotImplementedError

network = ONNXConverter().to_neural_network(onnx)
y_v = utilities.execute_network(network, x_v)
weights = []

for _, node in network.nodes.items():
    if isinstance(node, nodes.FullyConnectedNode):
        weights.append(node.weight)

match model:
    case 0:
        w = weights[0]
        for i in range(w.shape[1]):
            if w[0, i] > 0 if y_v > 0 else w[0, i] < 0:
                x_a[i] -= 10 ** -precision
            else:
                x_a[i] += 10 ** -precision

        y_a = np.matmul(w, x_a)
        y_a_p = mulprec(w, x_a, precision)

    case 1:
        w = weights[0]
        yt = np.argmax(y_v)
        for i in range(w.shape[1]):
            if w[yt, i] > 0 if yt > 0 else w[yt, i] < 0:
                x_a[i] -= 10 ** -precision
            else:
                x_a[i] += 10 ** -precision

        xa_rep = np.zeros((x_a.shape[0], 10))
        for i in range(10):
            xa_rep[:, i] = x_a[:, 0]
        y_a = np.argmax(np.matmul(w, x_a))
        y_a_p = np.argmax(mulprec(w, xa_rep, precision))

    case _:
        # TODO
        raise NotImplementedError

print(f'Prediction of x_a with double precision   = {y_a}')
print(f'Prediction of x_a with p digits precision = {y_a_p}')
